==============================
📝 TEAM MEMBER B - TODO LIST
==============================

1. Improve and Harden the Config System
----------------------------------------
[x] Validate `listen` is a valid number
[x] Validate root paths exist or fallback gracefully
[x] Support default values (e.g., default to `/index.html` if not set)
[x] Return `error_page` correctly (coordinate with Team A’s Response)

2. Support `error_page` Directive
----------------------------------
[x] Parse and store `error_page` (Already Done ✅)
[x] Add helper method:
        const std::string* Config::getErrorPage(int code) const
[ ] Coordinate with Team A to serve error pages (404, 405, etc.)

3. Support Uploads (BONUS Feature)
-----------------------------------
[ ] In CGI or POST handler, write request body into `upload_dir`
[ ] Use `upload_dir` field from `LocationConfig` if defined
      Example logic:
        if (!upload_dir.empty()) {
            std::ofstream out(upload_dir + "/file.txt");
            out << request.getBody();
        }

4. Final Integration & Testing
-------------------------------
[ ] Provide headers so Team A can use:
      - `Config` class
      - `CGIHandler` class

[ ] Test all integrated scenarios:
    [ ] `/` returns static page
    [ ] `/cgi-bin/test.py` runs correctly
    [ ] `DELETE` or `PUT` returns 405 (method not allowed)
    [ ] Non-existent path returns 404
    [ ] CGI errors are handled and logged properly

5. Write Documentation (README.txt)
------------------------------------
[ ] Document `Config` system:
    - What it parses
    - How to add new location blocks

[ ] Document `CGIHandler`:
    - How CGI execution works
    - What environment variables are passed

--------------

For cgi :

### 1. ❗ **Error Output (stderr) Handling**

> You are not capturing the script’s `stderr`.

* **Why important:** If a CGI script crashes or prints an error, you won’t see it.
* ✅ Fix idea: Add a third pipe for `STDERR_FILENO` (like you did for `STDOUT_FILENO`).

---

### 2. ❓ **Timeout Support** (Optional/Bonus)

* **Why important:** A buggy script might hang forever.
* Add a timeout to `waitpid()` or use `alarm()` inside the child.

---

### 3. 🧼 **Environment Variable Cleanup**

You're building `envp` from `std::vector<char*>`, but not freeing them (minor issue since the child process is `execve`'d or exits).

* But if `execve` fails, you may want to manually free or avoid leaking pointers (not critical here).

---

### 4. 💡 **Header Validation** (in output)

> Your CGI script returns something like:

```text
Content-Type: text/html

<html>...</html>
```

* You're returning this **raw** to the socket.
* ❓ Do you check that at least `Content-Type` exists?
* 💡 Idea: Add a parser to check for missing required headers (optional, can be part of `Response` logic later).

---

### 5. ✅ **Signal Handling** (for robustness)

If you're interrupted during the CGI child run, you may want to:

* Reap zombies (`SIGCHLD`)
* Use `WIFEXITED(status)` to check if child exited cleanly

---

## ✅ Optional: Add Debug Logging

You could sprinkle in some optional debug prints like:

```cpp
std::cerr << "Running CGI: " << scriptPath << "\n";
std::cerr << "Input: " << inputBody << "\n";
std::cerr << "Output: " << output.substr(0, 100) << "\n";
```

---

## 📦 Summary Table: Audit Result

| Component           | Status     | Recommendation                                  |
| ------------------- | ---------- | ----------------------------------------------- |
| `stdin/stdout` pipe | ✅ Good     | -                                               |
| `envp` setup        | ✅ Good     | Consider cleaning up if exec fails              |
| `execve()` fallback | ✅ OK       | Exits if script fails                           |
| `stderr` support    | ❌ Missing  | Optional: capture stderr from CGI               |
| Timeout handling    | ❌ Missing  | Optional: add timeout to prevent hang           |
| Header validation   | ❌ Not done | Optional: validate output includes Content-Type |
| Debug/logging       | ❓ Optional | Print for debugging script path/input/output    |
| Memory safety       | ✅ Good     | Leak risk only if `execve()` fails              |

---


### 🔹 PHASE 5 — SERVER INTEGRATION (how your logic plugs into Team A's code)

12. `WebServer.hpp`
13. `WebServer.cpp`

> 🔍 Here you’ll see how your config + CGI logic is used in the actual request/response loop.

---

### 🔹 PHASE 6 — TESTING + ENTRYPOINT

14. `main.cpp`
15. `Makefile`

> 🔍 Finally, review how everything is tied together and compiled.

---

## ✅ Your Review Plan (Step-by-Step)

You can now send me files in this order — starting with:

📂 `config/LocationConfig.hpp`

And I’ll begin line-by-line explanations for each.

---

When you're ready, send the **first file**:
**→ `LocationConfig.hpp`**
and we’ll begin.
