<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Siege Test - Webserv</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="/styles/siege.css" />
</head>
<section class="siege-explainer container siege-container">
    <h1 class="text-center mb-3">Siege Stress Testing</h1>

    <p class="text-light">
        <strong>Siege</strong> is a command-line tool for HTTP load and stress testing.
        It simulates multiple users accessing a server at the same time and reports
        how well the server handles the load.
    </p>

    <p class="text-light">
        <strong>How to use it with our server:</strong> from the minishell, run
        <code>siege -c 200 -t 30S http://localhost:8080/</code>.
        This launches 200 concurrent clients for 30 seconds and records availability,
        response times, and throughput.
    </p>

    <p class="text-light">
        <strong>In our project:</strong> we used Siege to verify that our Webserv
        implementation could serve requests reliably under heavy concurrency,
        detect potential memory leaks, and ensure connections close properly.
    </p>

    <p class="text-light">
        <strong>Why it is required:</strong> evaluation rules demand availability above
        99.5% for a simple GET, no hanging connections, and stable memory usage over
        indefinite Siege runs.
    </p>

    <h3 class="mt-4 mb-3">Our latest results</h3>
    <div class="metrics-grid">
        <div class="metric-card" data-key="availability" data-value="100.00" data-target=">=99.5%">
            <div class="metric-label">Availability</div>
            <div class="metric-value">100.00%</div>
            <div class="metric-target">Target: ≥ 99.5%</div>
        </div>

        <div class="metric-card" data-key="response_time" data-value="0.03" data-target="<=0.30s">
            <div class="metric-label">Avg Response Time</div>
            <div class="metric-value">0.03 s</div>
            <div class="metric-target">Target: ≤ 0.30 s</div>
        </div>

        <div class="metric-card" data-key="transaction_rate" data-value="248.89">
            <div class="metric-label">Transaction Rate</div>
            <div class="metric-value">248.89 req/s</div>
            <div class="metric-target">Higher is better</div>
        </div>

        <div class="metric-card" data-key="throughput" data-value="23.26">
            <div class="metric-label">Throughput</div>
            <div class="metric-value">23.26 MB/s</div>
            <div class="metric-target">Higher is better</div>
        </div>

        <div class="metric-card" data-key="failed_transactions" data-value="0" data-target="=0">
            <div class="metric-label">Failed Transactions</div>
            <div class="metric-value">0</div>
            <div class="metric-target">Target: 0</div>
        </div>

        <div class="metric-card" data-key="longest_transaction" data-value="0.73" data-target="<=1.0s">
            <div class="metric-label">Longest Transaction</div>
            <div class="metric-value">0.73 s</div>
            <div class="metric-target">Target: ≤ 1.0 s</div>
        </div>
    </div>
</section>



<script>
    (function () {
        const goals = {
            availability: v => v >= 99.5,
            response_time: v => v <= 0.30,
            failed_transactions: v => v === 0,
            longest_transaction: v => v <= 1.0
        };
        document.querySelectorAll('.metric-card').forEach(card => {
            const key = card.dataset.key;
            const raw = parseFloat(card.dataset.value);
            if (goals[key]) {
                card.classList.add(goals[key](raw) ? 'good' : 'bad');
            }
        });
    })();
</script>

</html>